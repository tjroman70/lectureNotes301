HW 10 due Tuesday, November 18
    Typo: problem 2 should have "x" as the function parameter, not "num"


Exam 3 is Thursday, November 20
    - will post details by the end of the week
    - will review for the exam some on Tuesday, November 18
    - Jacob will have a review session from 4-5:30 on Tuesday, November 18
        in DUE 1118

//////////////////////////////

Today:
- Working with recursive functions
- Loop invariants and loop correctness

///////////////////////////

Recursive functions

- exactly the same idea

if (base case condition) {
    answer = (something)

    //prove the postconditions
} else {

    //what to do here?

    //we must prove the preconditions (requires) for the function

    recursive call

    //what can we do here?
    //use the postconditions (ensures) as premises

    answer = (something)

    //prove the postconditions
}

//if we want some postcondition after an if/else, what do we do?
//answer == something (maybe this is the postcondition)
//prove that postcondition in the if and in the else

return answer



/////////////////////////////////

Example (mult_rec.sc):

- multiplication through repeated (recursive) addition
- write function contract
- do verification

////////////////////////////

(in-class quiz)

/////////////////////////////

Validating loops.

while (condition) {
    statements
}


<-- what do we know here?

condition is false



<-- why is this more challenging than if-statements?


need: loop invariants
should be true before loop begins
should be true at end of each iteration

//////////////////////////////

Solution: kind of like mathematical induction

Come up with a loop INVARIANT that summarizes the behavior
in a loop

- invariant should be true before loop begins
- should be STILL true at the end of each iteration


Steps to proving correctness of a loop:
----------------------------------------

1) Prove the invariant is true before the loop begins

    (what is this like in mathematical induction?)
    base case


2) Assume the invariant is true at the beginning of an iteration.
    Prove the invariant still holds at the end of the iteration.

    (what is this like in mathematical induction?)
    inductive Steps

    the assume is like the inductive hypothesis



/////////////////////////

When loop ends, you know two things:
    1) About the invariant?  true! we proved it is true at the end 
        of each iteration, and after the loop is at the end of 
        the last iteration


    2) About the loop condition? false! we exited the loop, so its 
        condition must be false




If your loop is in a function, you can use those two pieces
to prove the postcondition of the function.

(And if you can't, you need to make your invariant stronger.)

/////////////////////////

Loop invariant block: just inside the loop


//prove invariants here

while (condition) {
    Invariant(
        Modifies(list all variables modified in loop),
        invariant1,
        invariant2,
        ...
    )

    //use invariants as a premise

    code for the loop

    //prove the invariants still hold
}


/////////////////////////

Example: see code for multiplication with repeated addition
    using a loop (mult_loop.sc)

--> can we use the function contract from recursive implementation?

yes


////////////////////

--> should the test cases/asserts be different? no

///////////////////

<-- stopped here, will continue on Tuesday

///////////////////

--> what if the loop condition was "i < y" instead?


/////////////////////

Next time:
- more with loop invariants
- writing recursive definitions for postconditions/
    invariants
- review for exam 3